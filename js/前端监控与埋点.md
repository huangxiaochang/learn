前端的监控与埋点
============

## 监控
前端监控可以分为以下三大类型
- 异常监控
- 性能监控
- 数据监控

### 异常监控
当在任务执行的过程中发生的异常，且没有被捕获的处理，异常会沿着调用栈一层层往外抛出，如果在调用栈路径上(包括全局上下文)都没有捕获处理，那么js引擎将会终止当前任务的执行，但是会继续执行下一个任务。

#### js异常错误的类型
- 语法错误
	一般在开发阶段就可以发现
	
- ajax请求错误
	可以通过请求的返回回调中进行埋点，如返回状态码为500时，进行异常上报。
	1.重写XMLHttpRequest来处理所有的请求，而不需要每个接口都进行埋点
	
	2.或者为了不重写XMLHttpRequest原型的方法，可以使用监听XMLHttpRequest对象的方式来进行埋点。如
	
```
	(function initListenAjax () {
		// 出发相应的事件
		function ajaxEventTrigger (event) {
			var ajaxEvent = new CustomEvent(event, {detail: this})
			// 分发一个ajaxEvent
			window.dispatchEvent(ajaxEvent)
		}
		
		var preXHR = XMLHttpRequest
		function newXHR () {
			varxhr = new preXHR()
			xhr.addEventListener('load', function (ev) {
				ajaxEventTrigger.call(this, 'ajaxLoad')
			})
			xhr.addEventListener('loadend', function (ev) {
				ajaxEventTrigger.call(this, 'ajaxLoadEnd')
			})
			xhr.addEventListener('progress', function (ev) {
				ajaxEventTrigger.call(this, 'ajaxProgress')
			})
			xhr.addEventListener('timeout', function (ev) {
				ajaxEventTrigger.call(this, 'ajaxTimeout')
			})
			xhr.addEventListener('readystatechange', function (ev) {
				ajaxEventTrigger.call(this, 'ajaxReadyStateChange')
			})
			xhr.addEventListener('error', function (ev) {
				ajaxEventTrigger.call(this, 'ajaxError')
			})
			return xhr
		}
		window.XMLHttpRequest = newXHR
		
		
	}())
	
	window.addEventListener('', function (ev) {
		// 在这里进行监控埋点
		
	})
```

- 静态资源加载异常
	在事件的捕获阶段进行捕获
	
- 跨域脚本异常
	1.相关的js文件上加上Access-Control-Allow-Origin:*的response header
	2.引用相关的js文件时加上crossorigin属性
	
- iframe异常
	使用iframe的引用window对象的onerror来监听
	
- Promise异常
	1.catch回调函数
	2.unhandledrejection事件监听
	
- 第三方框架中的错误
	使用第三方框架提供的错误处理接口。如Vue中的errorHandler。 
	
- 其他异常（页面崩溃等）
	借助server worker来监听

#### js异常处理的方式

##### 1.try-catch

try-catch异常处理只能捕获运行时的非异步错误，对于语法错误和异步错误是捕获不到的。
如：
###### 语法错误
```
try {
	var a = 1；// 中文分号
} catch(err){
	console.log(err) // 这里不能捕获到语法错误
}
```
###### 异步错误
try {
	setTimeout(function () {
		console.log('111')
		a // 发生错误
	}, 0)
} catch (err) {
	console.log(err, 'err') // 这里捕获不到异步错误
}

##### 2.window.onerror

window.onerror处理异常可以捕获到运行时的同步和异步错误，但是不能捕获到语法错误。（**window.onerror的异常监听要定义在所有代码的全面，否者在定义的前面的代码的异常错误，不会被它捕获到**）
如：
###### 语法错误
```
window.onerror = function (msg, url, row, col, error) {
	console.log(err) // 这里捕获不到语法错误
	// **这里需要返回true，否者异常还是会往外抛出，所以错误会在控制台中打印**
	return true
}
var a = 1；// 中文分号的语法错误
```
###### 同步错误
```
<script>
window.onerror = function (msg, url, row, col, error) {
	console.log(err) // 这里可以捕获到同步错误
	// **这里需要返回true，否者异常还是会往外抛出，所以错误会在控制台中打印。
	return true
}
function fn () {
	console.log('11')
	a;
}
fn()
// 下面的语句不会得到执行，因为当异常错误抛出到全局window.onerror之后，虽然能捕获，但是没有处理,所以当前任务终止执行，然后处理下一个任务。
console.log('不会执行这里')

</script>
<script>
	// 这里是下一个任务，所以上一个任务的错误不会影响这个任务
	console.log('这里的全局脚本会得到执行')
</script>
```

###### 异步错误

```
window.onerror = function (msg, url, row, col, error) {
	console.log(err) // 这里可以捕获到同步错误
	// **这里需要返回true，否者异常还是会往外抛出，所以错误会在控制台中打印。
	return true;
}

setTimeout(function () {
	console.log('000')
	a;
	// 因为该任务发生异常错误之后，全局onerror捕获异常，当前任务终止执行
	console.log('这里不会执行')
}, 0)

console.log('会执行这里')

setTimeout(function () {
// 会执行这里，因为和上面发生异常错误不是同一个任务
	console.log('4444')
}, 0)
```
###### 网络静态资源请求异常错误
window.onerror是不能捕获到网络异常错误的, 因为网络的异常错误事件是不冒泡的。但是可以在事件的捕获阶段进行捕获。
```
<script>
	// 这样定义的onerror是捕获冒泡
	window.onerror = function (msg, url, row, col, error) {
		console.log(err) // 这里不能捕获到网络的异常错误
	}
	// 可以使用捕获阶段来捕获
	window.addEventListener('error', function (ev) {
		// 可以捕获到图片请求异常错误，但是对于网络的状态码是不能获取到的
		console.log(ev) 
	}, true /*捕获阶段*/)
</script>

// html
<img src="./404.png"></img>
当图片找不到报404网络异常错误时，window.onerror时捕获不到的

// 对于一些网络的异常错误，同时可以使用其他的一些专有的方法来处理，如对于图片加载的异常，可以在img标签上定义onerror事件处理
<img src="" onerror="handlefn(event)"></img>

```

###### iframe中的错误
直接使用window.onerror是捕获不到iframe的异常错误信息的。要捕获iframe中的异常错误，需要使用iframe的引用的onerror来捕获。（不过只能捕获到同源的iframe中的异常错误，对于不同源的不能捕获到）
如
```
<--同源的iframe-->
<iframe src="./frame.html"></iframe>
<script type="text/javascript">
window.onerror = function (msg, url) {
 // 这里不能捕获到iframe中的异常错误
	console.log(msg, url)
	return true
}
// 需要使用iframe的window引用才能捕获的到，并且只能获取的到页面中的同源iframe.对于不同源的iframe，不同源的受控iframe可以在iframe内部获取到异常信息之后，在使用iframe的不同源信息交互的方式来把异常的信息发送的页面来监控
var frame = window.frames[0]
frame.onerror = function (msg, url, row, col, error) {
    console.log(msg, url, row, col, error)
    return true
}
</script>
```

**window.onerror主要是捕获意料之外的异常错误，try-catch主要是捕获能够预见的异常错误。，所以可以结合使用这两种异常处理方式。**

**对于外部跨越脚本，window.onerror虽然能捕获到错误，但是并能获取的脚本发生错误的行和列等错误信息.
要处理跨域js的错误，需要：
1.相关的js文件上加上Access-Control-Allow-Origin:*的response header
2.引用相关的js文件时加上crossorigin属性
**


##### 3. promise.catch和unhandledrejection
对于promise内部和reject抛出的异常错误，try-catch和window.onerroor都是无能为力的，是捕获不到的。所以对于promise的异常错误，只能通过Promise提供的catch回调函数或者监听unhandledrejection事件来进行捕获处理.
如

```
<script>
var p = new Promise(function (resolve, reject) {
	a;
	// 或者reject('error')抛出的错误
})
.catch(function (err) {
	// 通过catch回调函数来捕获处理Promise的异常错误
	console.log(err)
})
// 或者(目前浏览器的兼容性比较差)，注意，unhandledrejection事件也不会捕获到不同源的外部脚本的Promise错误
window.addEventListener("unhandledrejection", function(e){
  e.preventDefault()
  console.log(e.reason); // 这里是捕获到promise异常错误
  return true;
});
</script>
```

#### 异常上报的方式

##### 动态创建img标签
通过创建img标签的方式进行异常上报的优势
- 可以跨域
- 简单方便

##### ajax请求
ajax请求可以上传复杂的数据

#### 异常监控考虑点
以下为一个前端异常监控系统一般需要根据业务进行考虑的点
- 需要上传的异常数据，如用户权限，设备参数等数据
- 异常本地存储延迟上传
- 异常的重要程度
- 异常上报的时机
- 异常上报的方式，主体等。如单点上传，批量上传，用户自动上传，自动上传等
- 异常监控的逻辑代码不能影响系统的性能（可以借助web worker开启一个线程来处理异常的相关操作）。

#### 异常的分析，统计，反馈
异常的分析，统计，反馈等需要建立一个系统的日志服务器，进行对上报的异常信息过滤，分析，统计，反馈推送等。这是一个大模块，需要根据业务的具体情况来架构。


### 性能监控
前端性能监控主要是监听页面的用户体验，常见的性能监控有：
- 首屏加载时间
- 白屏时间
- http请求响应时间
- 静态资源下载时间
- 页面渲染时间
- 页面交互动画时间


### 数据监控
前端数据监控主要监控以下的数据类型：
- 页面的点击量和浏览量
- 用户在某一个页面的停留时间
- 用户通过什么入口来访问页面
- 用户在相应的页面中触发的行为



## 埋点
常用的前端埋点方式：
- 代码埋点
	代码埋点即在业务代码中需要埋点的地方编写埋点代码，如在点击事件处理程序中编写埋点代码，发送相关收集信息给server端。
	优点
    * 可以在任意地方，任意时刻，精准发送或者保存所需要的监控数据。
      缺点
    * 工作量大，每个组件都需要添加相应的埋点代码

- 可视化埋点
	可视化埋点即将业务代码和埋点代码分离，提供一个可视化交互页面，输入业务代码，通过这个可视化系统，在业务代码中自动添加埋点代码，最后输出业务代码和埋点代码。
    优点
    * 埋点效率高，可视化系统可以复用
    * 开发环境下的业务代码中没有埋点代码，有利于开发者只关心业务逻辑

	缺点
	
	* 可视化埋点的控件有限，不能手动定制一些特殊的埋点逻辑
	
- 无埋点
	无埋点即全埋点，在前端任意一个事件都被绑定一个标识，所有的事件都被分别记录下来。然后在定期上传记录文件，配合文件解析，解析出想要的数据。
	优点
	* 由于采集的是全量数据，在开发迭代的过程中不需要关注埋点逻辑，也不会出现漏埋，误埋的情况。

	缺点
	* 会采集到一些无用的数据，数据传输压力大
	* 无法灵活定制各个事件所需的数据







