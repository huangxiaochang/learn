JavaScript引擎原理
================

## js引擎的定义
	对于高级语言(如JavaScript)编写的代码，cpu是不能直接识别，cpu只能识别cpu的指令。所以对于js源码，需要经过编译成机器码，才能被cpu识别执行。而js引擎就是负责吧js源码解析和编译成机器码的程序(包括js变量的内存管理等功能)。

## 知识点
- 解释型语言：可以被一边编译，一边执行的语言。它是在运行的时候先编译再执行，这种方式被称为即时编译(Just-in-time compilation), 简称JIT。
- 编译型语言： 先把整个源码编译成字节码或者机器码，然后用户使用的是编译后的字节码或者机器码，所以执行的速度比解释型快很多。
- 字节码：代码的中间形式，是和平台无关的，是一种比较接近汇编的代码形态。
- 机器码：和平台相关的，也叫本地码，因为不同的平台，cpu的指令集是不同的，机器码是cpu能够识别并执行的代码。


## js引擎执行代码的流程
	虽然不同的引擎，工作的流程不完全相同，但是大致的流程是相似的。
	js源码 -> toekn元信息(词法分析) -> ast(语法分析) -> 字节码 -> 机器码(汇编)  	   
	在源码到ast的过程中，会进行语法的检查，如果存在错误的语法，会停止代码的后续编译工作，并且进行语法错误报告
	
	1.解析器(parser)负责将js源码解析转化成ast。
	2.解释器(interpreter),负责将ast转换为字节码，并且解释执行字节码，同时收集优化所需的信息。
	3.编译器(compiler)利用解释器所收集的优化信息，将某些字节码转换为机器码(汇编码)。
	4.垃圾回收模块负责将程序不再需要的内存空间进行回收。

## v8引擎

### v8引擎执行速度执行比较快的原因
- 字节码缓存
  一开始，v8引擎是直接从ast就编译成了机器码，这也是v8引擎执行速度快的一个原因，但是在5.9之后的版本，又引入字节码，原因是把源码直接编译成机器码需要的内存比较大。

- 隐藏类
  由于JavaScript是一种动态类型的语言，是在执行的时候，才能确定变量的类型的，同时对于对象属性的访问，也是只能在运行时才能确定。
  js引擎内部对于对象的属性名和属性值是分开存储的，属性名回建立一张shape表来进行存储，不同对象具有相同属性时，会共享同一个shape表。
  如图

![shape](https://mathiasbynens.be/_img/js-engines/shape-2.svg)

  js引擎对于对象属性的访问的优化：
  当访问过某个属性之后，会把该属性的偏移内联缓存在字节码中，下次访问时，不再需要去检索改属性，直接可以获取的它的偏移量。如
![shape2 优化](https://mathiasbynens.be/_img/js-engines/ic-4.svg)
	
	对于原型对象上的属性的检索：
	检索实例对象原型上的属性时，js引擎会内联缓存已经检索的相关信息，下次再检索时，会根据这些信息来直接可以快速访问到相应的属性，而不需要从头开始查找。
![shape3 原型检索](https://mathiasbynens.be/_img/js-engines/ic-validitycell.svg)
当原型没有改变时，内联缓存的ValidityCell字段为true,可以直接从内联缓存的检索信息中检索相应的属性，而不用根据原型链和shape表来查找。

**所以在编写代码，尽量减少在运行时，改变原型对象的属性，因为会导致内联缓存的ValidityCell的标志失效，属性的检索会从头开始查找，如果需要实在需要改变原型对象属性，可以在其他代码运行之前来进行操作**


- 执行过程中进行信息收集优化
  对于热点函数，经过多次调用之后，会进行函数类型的分析，会把类型稳定的函数，生成高效的机器码。此外，如果后面改函数的类型发生了改变，那么会导致优化失效，那么该函数会退回到字节码。（引擎一般只优化热点函数等比较频繁使用的代码成机器码，因为机器码比字节码大很多，需要更多的内存）
  如：
  ```
  	function add (a, b) {
  		return a + b
  	}
  	
  	for (var i = 0 ; i < 1000; i++) {
  		// 多次调用，并且参数的类型和返回值的类型都是相同的，add函数会被优化成机器码
  		add(i, i + 1)
  	}
  	// add函数由于前面优化成机器码的类型是number,但是此处的类型的string的，会导致add函数已经编译成的机器码失效，所有会回退到字节码，所以在编写代码时，建议尽量保持热点函数的一致性
  	add('1', '2')
  ```
- 不执行的函数，不会进行编译
- 内联缓存
  如果一个函数内部调用其他比较简单的函数，那么编译器会直接把被调用的函数的执行内容放到调用函数对应的位置。
  如
  ```
  	function add (a,b) {
  		return a + b
  	}
  	
  	function calc () {
  		var sum  = 0
  		for (var i = 0; i < 10000; i++) {
  			su += add(2,4)
  		}
  	}
  ```
  以上代码会被编译成：
  ```
  	function add (a,b) {
  		return a + b
  	}
  	
  	function calc () {
  		var sum  = 0
  		for (var i = 0; i < 10000; i++) {
  			su += 2+4
  		}
  	}
  ```
  
### v8主要模块
- 解析器
- 解释器：Ignition
- 编译器; Turbofan
- 垃圾回收模块：Orinoco
  




















