JavaScript引擎原理
================

## js引擎的定义
	对于高级语言(如JavaScript)编写的代码，cpu是不能直接识别，cpu只能识别cpu的指令。所以对于js源码，需要经过编译成机器码，才能被cpu识别执行。而js引擎就是负责吧js源码解析和编译成机器码的程序(包括js变量的内存管理等功能)。

## 知识点
- 解释型语言：可以被一边编译，一边执行的语言。它是在运行的时候先编译再执行，这种方式被称为即时编译(Just-in-time compilation), 简称JIT。
- 编译型语言： 先把整个源码编译成字节码或者机器码，然后用户使用的是编译后的字节码或者机器码，所以执行的速度比解释型快很多。
- 字节码：代码的中间形式，是和平台无关的，是一种比较接近汇编的代码形态。
- 机器码：和平台相关的，也叫本地码，因为不同的平台，cpu的指令集是不同的，机器码是cpu能够识别并执行的代码。


## js引擎执行代码的流程
	虽然不同的引擎，工作的流程不完全相同，但是大致的流程是相似的。
	js源码 -> toekn元信息(词法分析) -> ast(语法分析) -> 字节码 -> 机器码(汇编)  	   
	在源码到ast的过程中，会进行语法的检查，如果存在错误的语法，会停止代码的后续编译工作，并且进行语法错误报告。
	从源码到字节码/机器码为编译阶段，执行字节码/机器码即为执行阶段。在编译阶段会进行内存的分配，变量，作用域创建等(一般为ast到字节码/机器码阶段)。然后在执行阶段才确定this标识和变量的赋值等。(变量的提升的原因就是变量是在编译阶段在作用域声明，执行时是去作用域中查找，所以造成了变量声明提升的效果)
	
	1.解析器(parser)负责将js源码解析转化成ast。
	2.解释器(interpreter),负责将ast转换为字节码，并且解释执行字节码，同时收集优化所需的信息。
	3.编译器(compiler)利用解释器所收集的优化信息，将某些字节码转换为机器码(汇编码)。
	4.垃圾回收模块负责将程序不再需要的内存空间进行回收。

## v8引擎

### v8引擎执行速度执行比较快的原因
- 字节码缓存
  一开始，v8引擎是直接从ast就编译成了机器码，这也是v8引擎执行速度快的一个原因，但是在5.9之后的版本，又引入字节码，原因是把源码直接编译成机器码需要的内存比较大。

- 隐藏类
  由于JavaScript是一种动态类型的语言，是在执行的时候，才能确定变量的类型的，同时对于对象属性的访问，也是只能在运行时才能确定。
  js引擎内部对于对象的属性名和属性值是分开存储的，属性名回建立一张shape表来进行存储，不同对象具有相同属性时，会共享同一个shape表。
  如图

![shape](https://mathiasbynens.be/_img/js-engines/shape-2.svg)

  js引擎对于对象属性的访问的优化：
  当访问过某个属性之后，会把该属性的偏移内联缓存在字节码中，下次访问时，不再需要去检索改属性，直接可以获取的它的偏移量。如
![shape2 优化](https://mathiasbynens.be/_img/js-engines/ic-4.svg)
	
	对于原型对象上的属性的检索：
	检索实例对象原型上的属性时，js引擎会内联缓存已经检索的相关信息，下次再检索时，会根据这些信息来直接可以快速访问到相应的属性，而不需要从头开始查找。
![shape3 原型检索](https://mathiasbynens.be/_img/js-engines/ic-validitycell.svg)
当原型没有改变时，内联缓存的ValidityCell字段为true,可以直接从内联缓存的检索信息中检索相应的属性，而不用根据原型链和shape表来查找。

**所以在编写代码，尽量减少在运行时，改变原型对象的属性，因为会导致内联缓存的ValidityCell的标志失效，属性的检索会从头开始查找，如果需要实在需要改变原型对象属性，可以在其他代码运行之前来进行操作**


- 执行过程中进行信息收集优化
  对于热点函数，经过多次调用之后，会进行函数类型的分析，会把类型稳定的函数，生成高效的机器码。此外，如果后面改函数的类型发生了改变，那么会导致优化失效，那么该函数会退回到字节码。（引擎一般只优化热点函数等比较频繁使用的代码成机器码，因为机器码比字节码大很多，需要更多的内存）
  如：
  ```
  	function add (a, b) {
  		return a + b
  	}
  	
  	for (var i = 0 ; i < 1000; i++) {
  		// 多次调用，并且参数的类型和返回值的类型都是相同的，add函数会被优化成机器码
  		add(i, i + 1)
  	}
  	// add函数由于前面优化成机器码的类型是number,但是此处的类型的string的，会导致add函数已经编译成的机器码失效，所有会回退到字节码，所以在编写代码时，建议尽量保持热点函数的一致性
  	add('1', '2')
  ```
- 不执行的函数，不会进行编译
- 内联缓存
  如果一个函数内部调用其他比较简单的函数，那么编译器会直接把被调用的函数的执行内容放到调用函数对应的位置。
  如
  ```
  	function add (a,b) {
  		return a + b
  	}
  	
  	function calc () {
  		var sum  = 0
  		for (var i = 0; i < 10000; i++) {
  			su += add(2,4)
  		}
  	}
  ```
  以上代码会被编译成：
  ```
  	function add (a,b) {
  		return a + b
  	}
  	
  	function calc () {
  		var sum  = 0
  		for (var i = 0; i < 10000; i++) {
  			su += 2+4
  		}
  	}
  ```
  
### v8主要模块
- 解析器
- 解释器：Ignition
- 编译器; Turbofan
- 垃圾回收模块：Orinoco
  

## 引擎中的作用域，变量
引擎对于变量的查找，一般可以分为LHS和RHS查找。RHS查找一般意味着取变量的值，而LHS一般意味着查找变量是否声明过。当引擎抛出ReferenceError错误时，一般是关于作用域中变量解析失败的。TypeError错误暗示着作用域解析成功了，但是试图对这个结果进行了一个非法/不可能的动作。
作用域的确定，都是使用词法作用域来进行分析的，但是需要警惕的是，eval,setTimeout,setInterval等对作用域的运行时改变。
```
function foo (str, a) {
	// 运行时，执行var b = 3,会在foo的作用域中创建b变量，要避免这种情况的发生，可以使用严格模式:use strict
	eval(str) 
	console.log(a + b) // 4
}
var b = 2
foo('var b = 3', 1)
```
with语句对作用域的影响
with语句里面的代码块的作用域，是在实际运行时确定的。with语句实际上是创建一个新的作用域，作为with语句代码块内的首要作用域。

**尽管一个 with 块儿将一个对象视为一个词法作用域，但是在 with 块儿内部的一个普通 var 声明的变量(with作用域中不存在的变量)，将不会归于这个 with 块儿的作用域，而是归于包含它的函数作用域。**

```
function foo(obj) {
	with (obj) {
		// 该代码块中的首要作用域为obj, 如果在obj中查找不到变量时，会沿着作用域链进行查找
		
		a = 2;
		// o1中没有b变量，所以使用var声明的变量作为foo作用域中的变量
		// 而o2中存在b变量，所以这里改变的是obj作用域中的b变量
		var b = 99
	}
	// o1时输出: 99, o2时输出: undefined
	console.log(b)
}

var o1 = {
	a: 3
};

var o2 = {
	b: 3
};

foo( o1 );
console.log( o1.a ); // 2
console.log(o1.b) // undefined

foo( o2 );
console.log( o2.a ); // undefined,因为o2作用域中没有a属性，所以沿着作用域链查找，最后在全局作用域中隐式创建了变量a
console.log(o2.b) // 99
console.log( a ); // 2 -- 哦，全局作用域被泄漏了！
```

**eval,with语句可能会作用域，所以要尽量不使用eval，with，因为这会影响性能。一般引擎会在编译阶段做了很多的优化工作，这些优化原理可能是基于静态的词法分析代码，但是在使用evak,with之后，作用域可能发生了变化，会造成引擎对于作用域的不确定性，所以可能不回进行一些优化的工作。**




















