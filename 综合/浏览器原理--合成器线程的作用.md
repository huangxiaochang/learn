浏览器原理--合成器线程的作用
========================

## 浏览器对于事件的处理
对于输入事件，如手势，点击等，首先获取到的是浏览器主进程，然而浏览器进程只知道在屏幕哪里发生的事件，事件的类型等信息，并且不道怎么处理该事件，所以浏览器进程会该事件的相关信息发送的渲染进程，由渲染进程查找事件目标并运行附加的事件处理程序来适当处理事件。

## 合成器线程接收事件
在浏览器原理--渲染流程中，我们知道，合成器线程可以平滑地处理滚动事件通过合成光栅化层。
如果没有输入事件被绑定到页面，合成器线程可以完全独立于主线程创建新的合成帧。但是如果当页面绑定事件处理程序时，合成器线程必须要和主线程交互来决定合成帧的生成，因为事件监听器中可能会改变布局、分层，渲染指令集等（即会导致重排与重绘）。

### 非快速滚动区域
当一个页面合成显示时，合成线程会把绑定了事件监听器的区域标记成"非快速滚动区域"，当事件发生时，如果该事件发生在非快速滚动区域内，合成线程会把该事件发送给主线程并且等待主线程的处理。如果事件发生在非快速滚动区域之外，合成器线程会进行合成新的合成帧，而不需要等待主线程。

合成器线程把事件发送给主线程后，主线程会找到相应的目标，把相应的监听器函数添加到js引擎的任务队列中，然后再执行栈空闲时，执行任务队列中的任务，从而执行该监听器函数。

### 事件代理
开发时，我们常常使用事件代理模式来处理事件，比如在body上绑定事件监听器，但是这样会把整个页面都标记成了非快速滚动区域，这样会造成事件发生时，合成器线程都要等待主线程，但是有时我们可能对于页面中某部分的事件并关心，所以会浪费了组合器线程快速平滑滚动的能力。
为了减轻这种情况的发生，可以在绑定事件监听器的时候，设置passive:true选项，设置了该选项，会告诉浏览器在事件监听器中，永远不会调用preventDefault（如果调用，浏览器会忽略并抛出警告）来制止滚动，我们虽然会在主线程中处理该事件，但是合成器也可以继续合成新帧。

如：
```
document.body.addEventListener('touchstart', event => {
	if (event.target  === area) {
		event.preventDefault();
	}
},{passive: true})
```

### 最小化到主线程的事件分派
因为浏览器的刷新频率为60帧/s,但是有些事件可能在1s内发生的频率超过60次，如果按照这个频率来分发事件到主线程，与屏幕刷新速度相比，他可能会触发过多的命中测试和JavaScript执行。所以为尽可能减少对主线程的过度调用，谷歌浏览器会收集连续事件(mousewheel,mousemove,touchmove等)和延时分发给主线程直到下一个requestAnimationFrame之前。对于离散的事件(click，keydown,touchstart等)则会立即分发。

### 使用GetCoaleCodevents获取帧内事件
对于大多数应用来说，合成事件可以满足提供良好的用户体验，如果正在构建诸如绘制应用程序和基于touchmove坐标放置路径之类的东西，则可能会在坐标之间丢失绘制平滑线。在这种情况下，可以使用GetCoaleCodevents来获取这些合并事件的信息。
如：
```
window.addEventListener('pointermove', event => {
    const events = event.getCoalescedEvents();
    for (let event of events) {
        const x = event.pageX;
        const y = event.pageY;
        // draw a line using x and y coordinates.
    }
});
```

